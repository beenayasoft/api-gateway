"""
API Gateway FastAPI avec compatibilit√© frontend existant et CORS configur√© pour le frontend
"""
import asyncio
import logging
from typing import Dict, Any
from fastapi import FastAPI, Request, HTTPException, status, Depends
from fastapi.responses import JSONResponse, Response
from fastapi.middleware.cors import CORSMiddleware
import httpx
import uvicorn

from config import SERVICES, LEGACY_ROUTE_MAPPING, GATEWAY_HOST, GATEWAY_PORT, DEBUG
from middleware import JWTMiddleware

# Configuration du logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Cr√©ation de l'application FastAPI
app = FastAPI(
    title="Beenaya API Gateway",
    description="Point d'entr√©e centralis√© pour l'architecture SOA avec compatibilit√© frontend",
    version="1.0.0",
    docs_url="/docs" if DEBUG else None,
    redoc_url="/redoc" if DEBUG else None
)

# ‚úÖ CONFIGURATION CORS POUR LE FRONTEND
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:8080",  # Frontend Vite
        "http://127.0.0.1:8080",
        "http://localhost:3000",  # React standard
        "http://127.0.0.1:3000",
    ],
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
    allow_headers=["*", "X-Tenant-ID", "x-tenant-id"],  # Ajout explicite
)

class ServiceRouter:
    """Router intelligent avec compatibilit√© frontend existant"""
    
    def __init__(self):
        self.services = SERVICES
        self.legacy_mapping = LEGACY_ROUTE_MAPPING
    
    def resolve_service(self, path: str) -> tuple[str, str]:
        """
        R√©sout intelligemment le service cible
        1. V√©rifie d'abord le mapping de compatibilit√©
        2. Puis la configuration normale des services
        """
        logger.info(f"üîç RESOLVE_SERVICE: D√©but r√©solution pour path='{path}'")
        
        # 1. V√©rification mapping de compatibilit√©
        logger.info(f"üîç STEP 1: V√©rification mapping exact pour '{path}'")
        if path in self.legacy_mapping:
            service_name, target_path = self.legacy_mapping[path]
            logger.info(f"‚úÖ STEP 1: Mapping exact trouv√© - service='{service_name}', target='{target_path}'")
            if service_name in self.services:
                service_url = self.services[service_name]["url"]
                logger.info(f"‚úÖ STEP 1: Service trouv√© - service_url='{service_url}'")
                logger.info(f"‚úÖ RESOLVE_SERVICE: Retour STEP 1 - url='{service_url}', path='{target_path}'")
                return service_url, target_path
            else:
                logger.error(f"‚ùå STEP 1: Service '{service_name}' non trouv√© dans SERVICES")
        else:
            logger.info(f"‚ÑπÔ∏è STEP 1: Pas de mapping exact trouv√© pour '{path}'")
        
        # 2. V√©rification mapping par pr√©fixe (pour routes dynamiques)
        logger.info(f"üîç STEP 2: V√©rification mapping par pr√©fixe pour '{path}'")
        for legacy_route, (service_name, new_route) in self.legacy_mapping.items():
            legacy_route_stripped = legacy_route.rstrip('/')
            logger.debug(f"üîç STEP 2: Test pr√©fixe '{legacy_route}' (stripped: '{legacy_route_stripped}') vs '{path}'")
            
            if path.startswith(legacy_route_stripped):
                logger.info(f"‚úÖ STEP 2: Pr√©fixe match - route='{legacy_route}', service='{service_name}', new_route='{new_route}'")
                
                if service_name in self.services:
                    # Remplacer le pr√©fixe
                    new_route_stripped = new_route.rstrip('/')
                    target_path = path.replace(legacy_route_stripped, new_route_stripped)
                    service_url = self.services[service_name]["url"]
                    
                    logger.info(f"‚úÖ STEP 2: Transformation - '{legacy_route_stripped}' -> '{new_route_stripped}'")
                    logger.info(f"‚úÖ STEP 2: Path final - '{path}' -> '{target_path}'")
                    logger.info(f"‚úÖ STEP 2: Service URL - '{service_url}'")
                    logger.info(f"‚úÖ RESOLVE_SERVICE: Retour STEP 2 - url='{service_url}', path='{target_path}'")
                    return service_url, target_path
                else:
                    logger.error(f"‚ùå STEP 2: Service '{service_name}' non trouv√© dans SERVICES")
        
        logger.info(f"‚ÑπÔ∏è STEP 2: Aucun pr√©fixe match trouv√© pour '{path}'")
        
        # 3. Configuration normale des services
        logger.info(f"üîç STEP 3: V√©rification configuration normale des services pour '{path}'")
        for service_name, config in self.services.items():
            logger.debug(f"üîç STEP 3: Test service '{service_name}' - routes: {config['routes']}")
            for route_prefix in config["routes"]:
                logger.debug(f"üîç STEP 3: Test route_prefix '{route_prefix}' vs '{path}'")
                if path.startswith(route_prefix):
                    service_url = config["url"]
                    logger.info(f"‚úÖ STEP 3: Match trouv√© - service='{service_name}', route_prefix='{route_prefix}'")
                    logger.info(f"‚úÖ RESOLVE_SERVICE: Retour STEP 3 - url='{service_url}', path='{path}'")
                    return service_url, path
        
        logger.error(f"‚ùå RESOLVE_SERVICE: Aucune route trouv√©e pour '{path}'")
        logger.error(f"‚ùå RESOLVE_SERVICE: LEGACY_MAPPING disponible: {list(self.legacy_mapping.keys())}")
        logger.error(f"‚ùå RESOLVE_SERVICE: SERVICES disponible: {list(self.services.keys())}")
        
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Aucun service configur√© pour le chemin: {path}"
        )
    
    async def health_check_all(self) -> Dict[str, Any]:
        """V√©rifie la sant√© de tous les services backend"""
        
        health_status = {
            "gateway": {"status": "healthy", "version": "1.0.0"},
            "services": {},
            "legacy_compatibility": "enabled"
        }
        
        overall_healthy = True
        
        async with httpx.AsyncClient(timeout=5.0) as client:
            tasks = []
            
            for service_name, config in self.services.items():
                health_url = f"{config['url']}{config['health']}"
                tasks.append(self._check_service_health(client, service_name, health_url))
            
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            for service_name, result in zip(self.services.keys(), results):
                if isinstance(result, Exception):
                    health_status["services"][service_name] = {
                        "status": "unreachable",
                        "error": str(result)
                    }
                    overall_healthy = False
                else:
                    health_status["services"][service_name] = result
                    if result["status"] != "healthy":
                        overall_healthy = False
        
        health_status["gateway"]["overall_status"] = "healthy" if overall_healthy else "degraded"
        return health_status
    
    async def _check_service_health(self, client: httpx.AsyncClient, service_name: str, health_url: str) -> Dict[str, Any]:
        """V√©rifie la sant√© d'un service individuel"""
        
        try:
            response = await client.get(health_url)
            
            if response.status_code == 200:
                return {
                    "status": "healthy",
                    "url": health_url,
                    "response_time": response.elapsed.total_seconds()
                }
            else:
                return {
                    "status": "unhealthy", 
                    "url": health_url,
                    "error": f"HTTP {response.status_code}"
                }
                
        except Exception as e:
            return {
                "status": "unreachable",
                "url": health_url, 
                "error": str(e)
            }

# Instance globale du router
router = ServiceRouter()

async def get_current_user(request: Request):
    """
    Dependency pour extraire et valider l'utilisateur √† partir du JWT
    Compatible avec le frontend existant
    """
    logger.info(f"üîê GET_CURRENT_USER: START - {request.method} {request.url.path}")
    
    # V√©rifier si la route est publique
    is_public = JWTMiddleware.is_public_route(request.url.path, request.method)
    logger.info(f"üîê GET_CURRENT_USER: Route publique check - {is_public}")
    
    if is_public:
        logger.info(f"‚úÖ GET_CURRENT_USER: Route publique acc√©d√©e - {request.method} {request.url.path}")
        return None
    
    # Extraire le token
    authorization = request.headers.get("authorization")
    logger.info(f"üîê GET_CURRENT_USER: Authorization header - {'Present' if authorization else 'Missing'}")
    if authorization:
        logger.info(f"üîê GET_CURRENT_USER: Authorization header value - {authorization[:20]}...")
    
    token = JWTMiddleware.extract_token(authorization)
    logger.info(f"üîê GET_CURRENT_USER: Token extracted - {'Present' if token else 'Missing'}")
    
    if not token:
        # Pour compatibilit√© frontend, retourner 401 avec format attendu
        logger.warning(f"‚ùå GET_CURRENT_USER: Acc√®s non authentifi√© √† une route prot√©g√©e - {request.method} {request.url.path}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token d'authentification requis",
            headers={"WWW-Authenticate": "Bearer"}
        )
    
    # Valider le token et retourner les informations utilisateur
    try:
        logger.info(f"üîê GET_CURRENT_USER: Validating token...")
        user = JWTMiddleware.validate_token(token)
        logger.info(f"‚úÖ GET_CURRENT_USER: Token valid - user_id: {user.get('user_id')}, tenant_id: {user.get('tenant_id')}")
        return user
    except Exception as e:
        logger.error(f"‚ùå GET_CURRENT_USER: Token validation failed - {str(e)}")
        raise

@app.get("/")
async def gateway_info():
    """Informations sur l'API Gateway"""
    
    return {
        "service": "api-gateway",
        "version": "1.0.0", 
        "status": "operational",
        "documentation": "/docs" if DEBUG else "disabled",
        "legacy_compatibility": "enabled",
        "endpoints": {
            "health": "/health/",
            "auth": "/api/auth/*",
            "tenants": "/api/tenants/*",
            "tiers": "/api/tiers/*",
            "legacy": "Mapping automatique des anciennes routes"
        },
        "services_backend": list(router.services.keys())
    }

@app.get("/health/")
async def health_check():
    """Health check de l'API Gateway et de tous les services"""
    
    health_data = await router.health_check_all()
    
    # D√©terminer le status code
    if health_data["gateway"]["overall_status"] == "healthy":
        return JSONResponse(content=health_data, status_code=200)
    else:
        return JSONResponse(content=health_data, status_code=503)

# Note: L'endpoint /tenants/current_tenant_info/ est g√©r√© par le routage standard via LEGACY_ROUTE_MAPPING

# Endpoint direct pour les taux de TVA (sans authentification)
@app.get("/api/quotes/vat-rates/", include_in_schema=True)
async def vat_rates_endpoint():
    """
    Endpoint direct pour les taux de TVA sans authentification requise
    """
    logger.info("Acc√®s direct √† l'endpoint des taux de TVA")
    
    # D√©finition des taux de TVA directement dans l'API Gateway
    vat_rates = [
        {
            'code': "0", 
            'name': "0%", 
            'rate': 0.0,
            'rate_display': "0%",
            'description': "Taux de TVA √† 0%",
            'is_default': False,
            'is_active': True
        },
        {
            'code': "5.5", 
            'name': "5.5%", 
            'rate': 5.5,
            'rate_display': "5.5%",
            'description': "Taux de TVA √† 5.5%",
            'is_default': False,
            'is_active': True
        },
        {
            'code': "10", 
            'name': "10%", 
            'rate': 10.0,
            'rate_display': "10%",
            'description': "Taux de TVA √† 10%",
            'is_default': False,
            'is_active': True
        },
        {
            'code': "20", 
            'name': "20%", 
            'rate': 20.0,
            'rate_display': "20%",
            'description': "Taux de TVA √† 20%",
            'is_default': True,
            'is_active': True
        }
    ]
    
    return vat_rates

@app.api_route("/{path:path}", methods=["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"])
async def proxy_request(
    request: Request, 
    path: str,
    current_user: dict = Depends(get_current_user)
):
    """
    Proxy intelligent avec compatibilit√© frontend existant
    """
    logger.info(f"üöÄ PROXY_REQUEST: START - Method: {request.method}, Path: /{path}")
    logger.info(f"üöÄ PROXY_REQUEST: Headers: {dict(request.headers)}")
    logger.info(f"üöÄ PROXY_REQUEST: Query params: {dict(request.query_params)}")
    
    # R√©soudre le service cible (avec mapping de compatibilit√©)
    try:
        logger.info(f"üîç PROXY_REQUEST: Calling router.resolve_service('/{path}')")
        service_url, target_path = router.resolve_service(f"/{path}")
        
        # Log d√©taill√© pour le d√©bogage
        logger.info(f"‚úÖ PROXY_REQUEST: Route r√©solue - /{path} -> service: {service_url}, path: {target_path}")
        
        # Construire l'URL compl√®te
        full_url = f"{service_url}{target_path}"
        logger.info(f"‚úÖ PROXY_REQUEST: URL compl√®te construite - {full_url}")
        
    except Exception as e:
        logger.error(f"‚ùå PROXY_REQUEST: Erreur lors de la r√©solution de la route /{path}: {str(e)}")
        logger.error(f"‚ùå PROXY_REQUEST: Exception type: {type(e).__name__}")
        logger.error(f"‚ùå PROXY_REQUEST: Exception args: {e.args}")
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Route non trouv√©e: /{path}"
        )
    
    # Pr√©parer les headers
    headers = dict(request.headers)
    logger.info(f"üìã PROXY_REQUEST: Headers initiaux - {headers}")
    
    # Ajouter les informations utilisateur si authentifi√©
    if current_user:
        headers["X-User-ID"] = str(current_user["user_id"])
        headers["X-Tenant-ID"] = str(current_user["tenant_id"])
        headers["X-User-Email"] = current_user.get("email", "")
        
        # LOG pour d√©bugger
        logger.info(f"üîê PROXY_REQUEST: User authenticated - {current_user['email']}, Tenant: {current_user['tenant_id']}")
    else:
        logger.info(f"üîê PROXY_REQUEST: No user authentication")
    
    # Nettoyer les headers probl√©matiques
    headers.pop("host", None)
    headers.pop("content-length", None)
    logger.info(f"üìã PROXY_REQUEST: Headers nettoy√©s - {headers}")
    
    # Lire le body de la requ√™te
    body = await request.body()
    logger.info(f"üìÑ PROXY_REQUEST: Body length: {len(body)} bytes")
    if body and len(body) < 1000:  # Log only small bodies
        logger.info(f"üìÑ PROXY_REQUEST: Body content: {body.decode('utf-8', errors='ignore')}")
    
    # Effectuer la requ√™te vers le service backend
    logger.info(f"üåê PROXY_REQUEST: Envoi requ√™te vers {full_url}")
    async with httpx.AsyncClient(timeout=30.0) as client:
        try:
            logger.info(f"üåê PROXY_REQUEST: httpx.request - method: {request.method}, url: {full_url}")
            logger.info(f"üåê PROXY_REQUEST: httpx.request - headers: {headers}")
            logger.info(f"üåê PROXY_REQUEST: httpx.request - params: {dict(request.query_params)}")
            
            response = await client.request(
                method=request.method,
                url=full_url,
                content=body,
                headers=headers,
                params=dict(request.query_params)
            )
            
            # Logger la requ√™te avec mapping
            logger.info(f"‚úÖ PROXY_REQUEST: Response re√ßue - {request.method} /{path} ‚Üí {full_url} ({response.status_code})")
            logger.info(f"‚úÖ PROXY_REQUEST: Response headers - {dict(response.headers)}")
            
            # Log response content if small
            if response.content and len(response.content) < 1000:
                logger.info(f"‚úÖ PROXY_REQUEST: Response content - {response.content.decode('utf-8', errors='ignore')}")
            
            # Retourner la r√©ponse directement sans re-s√©rialisation
            logger.info(f"‚úÖ PROXY_REQUEST: Returning response with status {response.status_code}")
            
            # Pr√©parer les headers de r√©ponse
            response_headers = {}
            for key, value in response.headers.items():
                if key.lower() not in ['content-encoding', 'transfer-encoding', 'connection']:
                    response_headers[key] = value
            
            return Response(
                content=response.content,
                status_code=response.status_code,
                headers=response_headers,
                media_type=response.headers.get('content-type', 'application/json')
            )
            
        except httpx.TimeoutException as e:
            logger.error(f"‚ùå PROXY_REQUEST: Timeout lors de la requ√™te vers {service_url} - {str(e)}")
            raise HTTPException(
                status_code=status.HTTP_504_GATEWAY_TIMEOUT,
                detail="Le service backend a mis trop de temps √† r√©pondre"
            )
        except httpx.RequestError as e:
            logger.error(f"‚ùå PROXY_REQUEST: Erreur de communication avec {service_url} - {str(e)}")
            logger.error(f"‚ùå PROXY_REQUEST: RequestError details - {e.__class__.__name__}: {e}")
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail=f"Service temporairement indisponible: {str(e)}"
            )
        except Exception as e:
            logger.error(f"‚ùå PROXY_REQUEST: Erreur inattendue lors du proxy - {str(e)}")
            logger.error(f"‚ùå PROXY_REQUEST: Exception type: {type(e).__name__}")
            logger.error(f"‚ùå PROXY_REQUEST: Exception args: {e.args}")
            import traceback
            logger.error(f"‚ùå PROXY_REQUEST: Traceback: {traceback.format_exc()}")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Erreur interne du gateway"
            )

if __name__ == "__main__":
    uvicorn.run(
        "main:app",
        host=GATEWAY_HOST,
        port=GATEWAY_PORT,
        reload=DEBUG,
        log_level="info"
    ) 